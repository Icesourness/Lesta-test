## Вопрос №1

По таблице ниже легко заметить, что у четного числа в двоичной системе в самом младшем разряде всегда будет стоять 0, а у нечетного - 1. 

Следовательно, достаточно узнать значение самого крайнего правого бита при помощи операции **"побитовое И"**

| 10-ая | 2-ая |
| ----------- | ----------- |
| 0    | 000   |
| 1    | 001   |
| 2    | 010   |
| 3    | 011   |
| 4    | 100   |
| 5    | 101   |

```python
def isEven(value):
  return value&1 == 0 # "отщипываю" самый правый бит (самый младший разряд) и сравниваю с нулем
```

Плюсы: Такое решение выполнится быстрее, так как побитовая операция И быстрее, чем операция деления с остатком.

*Если говорить про компилируемые ЯП, то выигрыш по быстродействию может сойти на нет из-за оптимизации компилятора (например, при умножении или делении на 2 компилятор можно сделать битовый сдвиг влево или вправо)*

Минусы: Менее читабельно по сранению с решением ниже; можно использовать только с целыми числами.
```python
def isEven(value):
  return value % 2 == 0
```

## Вопрос №2

Первая реализация использует внутренный класс, который представляет собой заполненный буфер. В ней сначала происходит вставка нового элемента, затем сравнение с пределом объема. Во второй реализации сначала идет сравнение с пределом объема. Если еще есть место, то объект добавляется, и высчитывается индекс, по которому произодет перезапись при добавлении элемента в буффер, когда он уже заполнен. Вторая реализация работает быстрее

1) 
```python
class Buffer_1:
    def __init__(self, max_size):
        self.buffer = []
        self.limit = max_size

    class __Filled:
        def append(self, to_add):
            self.buffer[self.index] = to_add
            self.index = (self.cur + 1) % self.limit
        def get(self):
            return self.buffer[self.index:] + self.buffer[:self.index]

    def add(self, to_add):
        self.buffer.append(to_add)
        if len(self.buffer) == self.limit:
            self.index = 0
            self.__class__ = self.__Filled

    def get(self):
        return self.buffer
```

2)
```python  
class Buffer_2():
    def __init__(self, max_size):
        self.buffer = []
        self.limit = max_size
        self.index = 0

    def add(self, to_add):
        if len(self.buffer) == self.limit:
            self.buffer[self.index] = to_add
        else:
            self.buffer.append(to_add)
        self.index = (self.index + 1) % self.limit

    def __getitem__(self, key):
        return(self.buffer[key])

    def get(self):
        return(self.buffer)
```

## Вопрос №3

Существует большое количество алгоритмов сортировок, которые отличаются по времени выполнения и затратам памяти. Как правило, наиболее быстрые алгоритмы имеют сложность **O(n*log(n))**, но надо иметь в виду, что в зависимости от данных, которые нужно отсортировать, результаты одного и того же алгоритма могут отличаться (например, если массив данных уже отсортирован, или если алгоритм случано выбрал неудачный опорный элемент). Так что нельзя никогда однозначно сказать, какая сортировка лучше. Делать выбор в пользу того или иного алгоритма нужно с учетом данных, подлежащих сортировке.

Самый быстрый алгоритм сортировки, который мне известен, это поразрядная сортировка, конкретно в данном случае LSD. Этот алгоритм имеет сложность **O(n)**, что часто дает победу по времени над другими алгоритмами.

Алгоритм, который я реализовал, работает полностью правильно только с **десятичными неотрицательными целыми** числами. Неотрицательность чисел связана с тем, что у отрицательных чисел старший бит равен 1. 

```python  
def my_sort(to_sort):
    sys_count = 10
    limit = max([len(str(i)) for i in to_sort])
    slots = [[] for _ in range(sys_count)]
    for i in range(0, limit):
        for j in to_sort:
            digit = (j // sys_count ** i) % sys_count
            slots[digit].append(j)
        to_sort = [j for k in slots for j in k]
        slots = [[] for _ in range(sys_count)]
    return to_sort
```